package pension_management_system.pension.benefit.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import pension_management_system.pension.benefit.dto.BenefitRequest;
import pension_management_system.pension.benefit.dto.BenefitResponse;
import pension_management_system.pension.benefit.entity.Benefit;

/**
 * BenefitMapper - Converts between Entity and DTOs
 *
 * What is MapStruct?
 * - Automatic code generator for object mapping
 * - Converts Entity ↔ DTO without writing boilerplate code
 * - Generates implementation at compile-time (no reflection = fast!)
 * - Type-safe (compilation errors if mapping is wrong)
 *
 * How it works:
 * 1. You define interface with mapping methods
 * 2. MapStruct generates implementation during compilation
 * 3. Generated code is simple Java (easy to debug)
 * 4. Spring automatically injects the implementation
 *
 * @Mapper - Tells MapStruct to generate implementation
 * componentModel = "spring" - Register as Spring bean (for dependency injection)
 *
 * Why use mapper?
 * - Separates API layer from database layer
 * - Reduces boilerplate code
 * - Easy to maintain
 * - Type-safe conversions
 */
@Mapper(componentModel = "spring")
public interface BenefitMapper {

    /**
     * Convert BenefitRequest → Benefit Entity
     *
     * Used when: Creating new benefit from API request
     *
     * What happens:
     * - Takes JSON request from user
     * - Converts to Entity that can be saved to database
     * - member field must be set separately (uses memberId to find Member)
     * - status, id, dates are set by service/database
     *
     * @Mapping explained:
     * - target = "member" - Field in Benefit entity
     * - ignore = true - Don't try to map this field automatically
     * - Why ignore? BenefitRequest has memberId (Long), but Benefit has member (Member object)
     *   Service will manually look up Member by ID and set it
     *
     * Example:
     * Input (BenefitRequest):
     * {
     *   "memberId": 123,
     *   "benefitType": "RETIREMENT",
     *   "requestedAmount": 50000
     * }
     *
     * Output (Benefit entity):
     * - member: null (will be set by service)
     * - benefitType: RETIREMENT
     * - requestedAmount: 50000
     * - status: null (will be set by service to PENDING)
     * - id: null (will be generated by database)
     */
    @Mapping(target = "member", ignore = true)
    @Mapping(target = "status", ignore = true)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "approvedAmount", ignore = true)
    @Mapping(target = "approvalDate", ignore = true)
    @Mapping(target = "paymentDate", ignore = true)
    @Mapping(target = "approvedBy", ignore = true)
    @Mapping(target = "rejectionReason", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    Benefit toEntity(BenefitRequest request);

    /**
     * Convert Benefit Entity → BenefitResponse
     *
     * Used when: Sending benefit data to client
     *
     * What happens:
     * - Takes entity from database
     * - Converts to DTO for API response
     * - Maps member details to separate fields
     *
     * @Mapping explained:
     * - source = "member.id" - Get id from nested member object
     * - target = "memberId" - Put it in memberId field of response
     *
     * Path notation:
     * - member.id → member.getId()
     * - member.firstName → member.getFirstName()
     *
     * Example:
     * Input (Benefit entity):
     * - id: 1
     * - member: Member{id=123, firstName="John", lastName="Doe"}
     * - benefitType: RETIREMENT
     * - status: APPROVED
     * - requestedAmount: 50000
     * - approvedAmount: 48000
     *
     * Output (BenefitResponse):
     * {
     *   "id": 1,
     *   "memberId": 123,
     *   "memberFirstName": "John",
     *   "memberLastName": "Doe",
     *   "memberEmail": "john@example.com",
     *   "benefitType": "RETIREMENT",
     *   "status": "APPROVED",
     *   "requestedAmount": 50000,
     *   "approvedAmount": 48000,
     *   ...
     * }
     */
    @Mapping(source = "member.id", target = "memberId")
    @Mapping(source = "member.firstName", target = "memberFirstName")
    @Mapping(source = "member.lastName", target = "memberLastName")
    @Mapping(source = "member.email", target = "memberEmail")
    BenefitResponse toResponse(Benefit benefit);

    /**
     * Update existing Benefit entity from BenefitRequest
     *
     * Used when: User updates benefit claim (before approval)
     *
     * What happens:
     * - Takes existing entity from database
     * - Updates only fields from request
     * - Preserves id, status, dates, etc.
     *
     * @MappingTarget - The object to update (passed by reference)
     *
     * Example:
     * Existing Benefit:
     * - id: 1
     * - requestedAmount: 50000
     * - status: PENDING
     * - notes: "Old notes"
     *
     * Update Request:
     * - requestedAmount: 55000
     * - notes: "Updated notes"
     *
     * After mapping:
     * - id: 1 (unchanged)
     * - requestedAmount: 55000 (updated)
     * - status: PENDING (unchanged)
     * - notes: "Updated notes" (updated)
     */
    @Mapping(target = "member", ignore = true)
    @Mapping(target = "status", ignore = true)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "approvedAmount", ignore = true)
    @Mapping(target = "approvalDate", ignore = true)
    @Mapping(target = "paymentDate", ignore = true)
    @Mapping(target = "approvedBy", ignore = true)
    @Mapping(target = "rejectionReason", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateEntityFromRequest(BenefitRequest request, @MappingTarget Benefit benefit);
}

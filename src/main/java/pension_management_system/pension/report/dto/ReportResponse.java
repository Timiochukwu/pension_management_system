package pension_management_system.pension.report.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import pension_management_system.pension.report.entity.ReportFormat;
import pension_management_system.pension.report.entity.ReportType;

import java.time.LocalDateTime;

/**
 * ReportResponse DTO - Data Transfer Object for report information responses
 *
 * Purpose: Carries report data from server to client (API response)
 *
 * What is a Response DTO?
 * - Contains data to send back to API client
 * - Separate from Entity (database model)
 * - Includes only data that client needs to see
 * - May format/transform data for better user experience
 * - Hides sensitive or internal fields
 *
 * Why use Response DTO instead of Entity?
 * - Security: Don't expose internal database structure
 * - Control: Choose exactly what data to return
 * - Computed fields: Add calculated values not in database
 * - Format: Present data in client-friendly format
 *
 * How it's used:
 * 1. Service retrieves Report entity from database
 * 2. Mapper converts Report → ReportResponse
 * 3. Controller wraps in ApiResponseDto
 * 4. Spring converts ReportResponse → JSON
 * 5. Client receives JSON in HTTP response body
 *
 * Example API Response:
 * {
 *   "success": true,
 *   "message": "Report generated successfully",
 *   "data": {
 *     "id": 1,
 *     "title": "Member Statement - John Doe",
 *     "reportType": "MEMBER_STATEMENT",
 *     "format": "PDF",
 *     "generatedAt": "2025-01-15T10:30:00",
 *     "requestedBy": "admin@example.com",
 *     "filePath": "reports/2025/01/member_statement_123.pdf",
 *     "fileSize": 245760,
 *     "formattedFileSize": "240.0 KB",
 *     "status": "COMPLETED",
 *     "downloadUrl": "/api/v1/reports/1/download"
 *   }
 * }
 *
 * Annotations Explained:
 * @Data - Lombok generates getters, setters, toString, equals, hashCode
 * @Builder - Enables builder pattern: ReportResponse.builder().id(1L).build()
 * @NoArgsConstructor - Generates no-argument constructor (required by Jackson)
 * @AllArgsConstructor - Generates constructor with all fields (used by @Builder)
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReportResponse {

    /**
     * REPORT ID
     *
     * Unique identifier for the report
     * Used for downloading, deleting, or referencing the report
     *
     * Example: 1, 2, 3, ...
     *
     * Client usage:
     * - "Download report #123"
     * - GET /api/v1/reports/123/download
     * - DELETE /api/v1/reports/123
     */
    private Long id;

    /**
     * REPORT TITLE
     *
     * Human-readable title displayed in UI
     *
     * Examples:
     * - "Member Statement - John Doe (January 2025)"
     * - "Monthly Contribution Summary - January 2025"
     * - "Employer Report - Tech Corp Ltd"
     *
     * UI display:
     * <h3>Monthly Contribution Summary - January 2025</h3>
     */
    private String title;

    /**
     * REPORT TYPE
     *
     * Category of report
     *
     * JSON value examples:
     * - "MEMBER_STATEMENT"
     * - "EMPLOYER_REPORT"
     * - "CONTRIBUTION_SUMMARY"
     * - "BENEFIT_CLAIMS"
     * - "ANALYTICS_DASHBOARD"
     * - "AUDIT_TRAIL"
     *
     * Client can use this to:
     * - Display appropriate icon
     * - Filter reports by type
     * - Show type-specific options
     */
    private ReportType reportType;

    /**
     * FILE FORMAT
     *
     * Format of the generated report file
     *
     * JSON value examples:
     * - "PDF"
     * - "EXCEL"
     * - "CSV"
     *
     * Client can use this to:
     * - Display format badge/icon
     * - Set correct MIME type for download
     * - Show format in file list
     *
     * UI example:
     * [PDF] Member Statement - John Doe
     */
    private ReportFormat format;

    /**
     * GENERATION TIMESTAMP
     *
     * When the report was generated
     * Formatted as ISO 8601 date-time string in JSON
     *
     * @JsonFormat annotation:
     * - Tells Jackson how to format LocalDateTime to JSON string
     * - pattern: Output format (yyyy-MM-dd'T'HH:mm:ss)
     * - ISO 8601 format for international compatibility
     *
     * JSON example: "2025-01-15T10:30:45"
     *
     * Client can display as:
     * - "Generated on: January 15, 2025 at 10:30 AM"
     * - "15/01/2025 10:30"
     * - "2 hours ago"
     *
     * JavaScript example:
     * const date = new Date("2025-01-15T10:30:45");
     * const formatted = date.toLocaleDateString();
     */
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime generatedAt;

    /**
     * REQUESTED BY
     *
     * Username or email of person who generated the report
     *
     * Examples:
     * - "admin@pensionsystem.com"
     * - "john.doe@company.com"
     *
     * UI usage:
     * - "Generated by: admin@pensionsystem.com"
     * - Filter reports by user
     * - Show "My Reports" vs "All Reports"
     *
     * Privacy consideration:
     * - In multi-tenant systems, only show this to admin users
     * - Regular users should only see their own reports
     */
    private String requestedBy;

    /**
     * ENTITY ID (OPTIONAL)
     *
     * ID of entity this report is about
     *
     * Interpretation depends on reportType:
     * - MEMBER_STATEMENT → Member ID
     * - EMPLOYER_REPORT → Employer ID
     * - CONTRIBUTION_SUMMARY → null (system-wide)
     *
     * Client usage:
     * if (reportType === "MEMBER_STATEMENT" && entityId) {
     *     // Show link to member profile
     *     <a href={`/members/${entityId}`}>View Member</a>
     * }
     */
    private Long entityId;

    /**
     * DATE RANGE START (OPTIONAL)
     *
     * Start date of report data range
     * Null if report includes all historical data
     *
     * JSON example: "2025-01-01T00:00:00"
     *
     * UI display:
     * "Period: January 1, 2025 - January 31, 2025"
     */
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime startDate;

    /**
     * DATE RANGE END (OPTIONAL)
     *
     * End date of report data range
     * Null if report includes data up to generation time
     *
     * JSON example: "2025-01-31T23:59:59"
     */
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime endDate;

    /**
     * REPORT PARAMETERS (OPTIONAL)
     *
     * Additional filter criteria or settings used
     * Stored as JSON string for flexibility
     *
     * Example values:
     * - "{\"status\":\"APPROVED\",\"minAmount\":5000}"
     * - "{\"contributionType\":\"MONTHLY\",\"groupBy\":\"employer\"}"
     * - null (if no custom parameters were used)
     *
     * Client can:
     * - Parse JSON to show applied filters
     * - Allow regenerating with same parameters
     *
     * Example client code:
     * const params = JSON.parse(response.parameters);
     * console.log("Filters applied:", params);
     * // Output: Filters applied: {status: "APPROVED", minAmount: 5000}
     */
    private String parameters;

    /**
     * FILE PATH
     *
     * Server path where report file is stored
     *
     * Examples:
     * - "reports/2025/01/member_statement_123_20250115_103045.pdf"
     * - "/var/pension/reports/employer_report_456.xlsx"
     *
     * Security consideration:
     * - Don't expose full absolute paths to clients
     * - Use relative paths or abstract identifiers
     * - Clients should use downloadUrl instead of constructing paths
     *
     * In production:
     * - May want to hide this field from clients
     * - Or return sanitized/relative path only
     */
    private String filePath;

    /**
     * FILE SIZE (BYTES)
     *
     * Size of report file in bytes
     *
     * Examples:
     * - 15360 (15 KB)
     * - 245760 (240 KB)
     * - 5242880 (5 MB)
     *
     * Client usage:
     * - Show before download: "File size: 240 KB"
     * - Estimate download time
     * - Check storage/bandwidth limits
     *
     * JavaScript example:
     * function formatBytes(bytes) {
     *     if (bytes < 1024) return bytes + ' B';
     *     else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
     *     else return (bytes / 1048576).toFixed(1) + ' MB';
     * }
     */
    private Long fileSize;

    /**
     * FORMATTED FILE SIZE
     *
     * Human-readable file size
     * Computed field (not stored in database)
     *
     * Examples:
     * - "512 B"
     * - "240.0 KB"
     * - "5.0 MB"
     *
     * Calculated in mapper or entity helper method
     * Saves client from having to format bytes
     *
     * UI display:
     * <span class="file-size">{report.formattedFileSize}</span>
     * // Output: <span class="file-size">240.0 KB</span>
     */
    private String formattedFileSize;

    /**
     * GENERATION STATUS
     *
     * Current status of report generation
     *
     * Possible values:
     * - "PENDING": Queued for generation
     * - "PROCESSING": Currently being generated
     * - "COMPLETED": Ready for download
     * - "FAILED": Generation failed
     *
     * Client usage:
     * switch(report.status) {
     *     case "PENDING":
     *         showQueuedIcon();
     *         break;
     *     case "PROCESSING":
     *         showSpinner();
     *         break;
     *     case "COMPLETED":
     *         showDownloadButton();
     *         break;
     *     case "FAILED":
     *         showErrorMessage(report.errorMessage);
     *         break;
     * }
     *
     * UI example:
     * [✓] Report completed - Download
     * [⟳] Generating report...
     * [!] Generation failed: Database timeout
     */
    private String status;

    /**
     * ERROR MESSAGE (OPTIONAL)
     *
     * Description of error if generation failed
     * Null if status is not "FAILED"
     *
     * Examples:
     * - "Database connection timeout"
     * - "Invalid date range: start date after end date"
     * - "Member ID 999 not found"
     * - "Insufficient permissions to view employer data"
     *
     * Client usage:
     * if (report.status === "FAILED") {
     *     alert("Report generation failed: " + report.errorMessage);
     * }
     *
     * Best practice:
     * - User-friendly messages (not technical stack traces)
     * - Actionable guidance when possible
     * - Don't expose sensitive system information
     */
    private String errorMessage;

    /**
     * DOWNLOAD URL (COMPUTED)
     *
     * API endpoint to download the report file
     * Computed field (not stored in database)
     *
     * Examples:
     * - "/api/v1/reports/1/download"
     * - "/api/v1/reports/123/download"
     *
     * Constructed in mapper or service:
     * String downloadUrl = "/api/v1/reports/" + report.getId() + "/download";
     *
     * Client usage:
     * <a href={report.downloadUrl} download>
     *     Download Report
     * </a>
     *
     * Or with authentication:
     * fetch(report.downloadUrl, {
     *     headers: {
     *         'Authorization': 'Bearer ' + token
     *     }
     * }).then(response => response.blob())
     *   .then(blob => {
     *       const url = window.URL.createObjectURL(blob);
     *       const a = document.createElement('a');
     *       a.href = url;
     *       a.download = report.title + '.' + report.format.toLowerCase();
     *       a.click();
     *   });
     */
    private String downloadUrl;

    /**
     * HELPER METHOD: Check if report is ready for download
     *
     * Convenience method for client-side logic
     * Can be included in JSON serialization if needed
     *
     * Not serialized by default (no @JsonProperty needed)
     *
     * Usage in service/mapper:
     * // This is just a helper, not in JSON response
     * // Status field is already in response for client to check
     */
    public boolean isCompleted() {
        return "COMPLETED".equals(this.status);
    }

    /**
     * HELPER METHOD: Check if report generation failed
     *
     * Not serialized in JSON response
     */
    public boolean isFailed() {
        return "FAILED".equals(this.status);
    }
}

package pension_management_system.pension.report.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import pension_management_system.pension.report.dto.ReportRequest;
import pension_management_system.pension.report.dto.ReportResponse;
import pension_management_system.pension.report.entity.Report;

/**
 * ReportMapper - Converts between Report Entity and DTOs
 *
 * What is MapStruct?
 * - Automatic code generator for object mapping
 * - Converts Entity ↔ DTO without writing boilerplate code
 * - Generates implementation at compile-time (no reflection = fast!)
 * - Type-safe (compilation errors if mapping is wrong)
 *
 * How it works:
 * 1. You define interface with mapping methods
 * 2. MapStruct generates implementation during compilation
 * 3. Generated code is simple Java (you can view it in target/generated-sources)
 * 4. Spring automatically injects the implementation
 *
 * @Mapper annotation:
 * - Tells MapStruct to generate implementation
 * - componentModel = "spring": Register as Spring bean for dependency injection
 *
 * Why use mapper?
 * - Separates API layer (DTOs) from database layer (Entity)
 * - Reduces boilerplate code (no manual field copying)
 * - Easy to maintain (change mapping in one place)
 * - Type-safe conversions (compile-time checking)
 * - Automatic null handling
 *
 * Example generated code (simplified):
 * @Component
 * public class ReportMapperImpl implements ReportMapper {
 *     public Report toEntity(ReportRequest request) {
 *         if (request == null) return null;
 *         Report report = new Report();
 *         report.setTitle(request.getTitle());
 *         report.setReportType(request.getReportType());
 *         // ... etc
 *         return report;
 *     }
 * }
 */
@Mapper(componentModel = "spring")
public interface ReportMapper {

    /**
     * Convert ReportRequest → Report Entity
     *
     * Used when: Creating new report from API request
     *
     * What happens:
     * - Takes JSON request from client
     * - Converts to Entity that can be saved to database
     * - Certain fields are ignored (set by service/database)
     *
     * Example Flow:
     * 1. Client sends JSON:
     * {
     *   "title": "Member Statement - John Doe",
     *   "reportType": "MEMBER_STATEMENT",
     *   "format": "PDF",
     *   "entityId": 123,
     *   "startDate": "2025-01-01T00:00:00",
     *   "endDate": "2025-01-31T23:59:59",
     *   "requestedBy": "admin@example.com"
     * }
     *
     * 2. Spring converts JSON → ReportRequest object
     *
     * 3. Mapper converts ReportRequest → Report entity:
     * Report report = new Report();
     * report.setTitle("Member Statement - John Doe");
     * report.setReportType(MEMBER_STATEMENT);
     * report.setFormat(PDF);
     * report.setEntityId(123);
     * report.setStartDate(...);
     * report.setEndDate(...);
     * report.setRequestedBy("admin@example.com");
     * // id, generatedAt, filePath, etc. are NOT set (ignored)
     *
     * 4. Service sets ignored fields:
     * report.setGeneratedAt(LocalDateTime.now());
     * report.setStatus("PENDING");
     *
     * 5. Repository saves to database
     *
     * @Mapping annotation explained:
     * - target: Field in Report entity
     * - ignore = true: Don't try to map this field
     *
     * Why ignore certain fields?
     * - id: Auto-generated by database
     * - generatedAt: Set by service (current timestamp)
     * - filePath: Set after report generation completes
     * - fileSize: Set after report generation completes
     * - status: Set by service (initially "PENDING")
     * - errorMessage: Only set if generation fails
     *
     * What gets mapped automatically:
     * - title: request.title → entity.title
     * - reportType: request.reportType → entity.reportType
     * - format: request.format → entity.format
     * - entityId: request.entityId → entity.entityId
     * - startDate: request.startDate → entity.startDate
     * - endDate: request.endDate → entity.endDate
     * - requestedBy: request.requestedBy → entity.requestedBy
     * - parameters: request.parameters → entity.parameters (needs conversion)
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "generatedAt", ignore = true)
    @Mapping(target = "filePath", ignore = true)
    @Mapping(target = "fileSize", ignore = true)
    @Mapping(target = "status", ignore = true)
    @Mapping(target = "errorMessage", ignore = true)
    @Mapping(target = "parameters", expression = "java(mapParametersToString(request.getParameters()))")
    Report toEntity(ReportRequest request);

    /**
     * Convert Report Entity → ReportResponse
     *
     * Used when: Sending report data to client
     *
     * What happens:
     * - Takes entity from database
     * - Converts to DTO for API response
     * - Adds computed fields (formattedFileSize, downloadUrl)
     *
     * Example Flow:
     * 1. Service retrieves entity from database:
     * Report entity:
     * - id: 1
     * - title: "Member Statement - John Doe"
     * - reportType: MEMBER_STATEMENT
     * - format: PDF
     * - generatedAt: 2025-01-15T10:30:45
     * - requestedBy: "admin@example.com"
     * - entityId: 123
     * - startDate: 2025-01-01T00:00:00
     * - endDate: 2025-01-31T23:59:59
     * - filePath: "reports/2025/01/member_statement_123.pdf"
     * - fileSize: 245760
     * - status: "COMPLETED"
     * - errorMessage: null
     *
     * 2. Mapper converts Report → ReportResponse:
     * ReportResponse response = new ReportResponse();
     * response.setId(1);
     * response.setTitle("Member Statement - John Doe");
     * response.setReportType(MEMBER_STATEMENT);
     * response.setFormat(PDF);
     * response.setGeneratedAt(...);
     * response.setRequestedBy("admin@example.com");
     * response.setEntityId(123);
     * response.setStartDate(...);
     * response.setEndDate(...);
     * response.setFilePath("reports/2025/01/member_statement_123.pdf");
     * response.setFileSize(245760);
     * response.setFormattedFileSize("240.0 KB"); // Computed!
     * response.setStatus("COMPLETED");
     * response.setErrorMessage(null);
     * response.setDownloadUrl("/api/v1/reports/1/download"); // Computed!
     *
     * 3. Controller wraps in ApiResponseDto:
     * {
     *   "success": true,
     *   "message": "Report retrieved successfully",
     *   "data": { ...response fields... }
     * }
     *
     * 4. Spring converts to JSON and sends to client
     *
     * @Mapping with expression:
     * - source: Field from entity
     * - target: Field in response
     * - expression: Java code to compute value
     *
     * formattedFileSize mapping:
     * - Calls entity's helper method: report.getFormattedFileSize()
     * - Returns: "240.0 KB", "5.0 MB", etc.
     *
     * downloadUrl mapping:
     * - Calls custom method: generateDownloadUrl(report.getId())
     * - Returns: "/api/v1/reports/1/download"
     */
    @Mapping(target = "formattedFileSize", expression = "java(report.getFormattedFileSize())")
    @Mapping(target = "downloadUrl", expression = "java(generateDownloadUrl(report.getId()))")
    ReportResponse toResponse(Report report);

    /**
     * CUSTOM METHOD: Convert parameters Map to JSON String
     *
     * Helper method for toEntity() mapping
     *
     * What it does:
     * - Takes Map<String, Object> from ReportRequest
     * - Converts to JSON string for database storage
     *
     * Example:
     * Input (from request.parameters):
     * Map<String, Object> params = new HashMap<>();
     * params.put("status", "APPROVED");
     * params.put("minAmount", 5000);
     * params.put("includeGraphs", true);
     *
     * Output (stored in entity.parameters):
     * "{\"status\":\"APPROVED\",\"minAmount\":5000,\"includeGraphs\":true}"
     *
     * Why JSON string?
     * - Database TEXT column can store any JSON
     * - Flexible schema (different reports need different params)
     * - Easy to add new parameters without changing database
     *
     * Implementation:
     * - Use Jackson ObjectMapper to convert Map → JSON
     * - Handle null case (return null)
     * - Handle exceptions (return null or empty JSON)
     *
     * Note: This is a default method (has implementation)
     * MapStruct will use this when mapping parameters field
     *
     * @param parameters Map of parameters from request
     * @return JSON string representation or null
     */
    default String mapParametersToString(java.util.Map<String, Object> parameters) {
        if (parameters == null || parameters.isEmpty()) {
            return null;
        }

        try {
            // Use Jackson ObjectMapper to convert Map to JSON string
            com.fasterxml.jackson.databind.ObjectMapper objectMapper =
                new com.fasterxml.jackson.databind.ObjectMapper();
            return objectMapper.writeValueAsString(parameters);
        } catch (Exception e) {
            // If conversion fails, return null
            // In production, you might want to log this error
            return null;
        }
    }

    /**
     * CUSTOM METHOD: Generate download URL
     *
     * Helper method for toResponse() mapping
     *
     * What it does:
     * - Takes report ID
     * - Constructs API endpoint URL for downloading
     *
     * Example:
     * Input: reportId = 123
     * Output: "/api/v1/reports/123/download"
     *
     * Client usage:
     * <a href={report.downloadUrl} download>
     *     Download Report
     * </a>
     *
     * Or with fetch:
     * fetch(report.downloadUrl)
     *     .then(response => response.blob())
     *     .then(blob => {
     *         // Trigger download
     *     });
     *
     * In production:
     * - Might include full domain: "https://api.example.com/api/v1/reports/123/download"
     * - Might include authentication token in URL or require header
     * - Might use signed URLs for security (temporary access)
     *
     * @param reportId ID of the report
     * @return Download URL path
     */
    @Named("generateDownloadUrl")
    default String generateDownloadUrl(Long reportId) {
        if (reportId == null) {
            return null;
        }
        return "/api/v1/reports/" + reportId + "/download";
    }
}

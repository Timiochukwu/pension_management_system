package pension_management_system.pension.report.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import pension_management_system.pension.report.entity.Report;
import pension_management_system.pension.report.entity.ReportFormat;
import pension_management_system.pension.report.entity.ReportType;

import java.time.LocalDateTime;
import java.util.List;

/**
 * ReportRepository - Database access layer for Report entity
 *
 * Purpose: Provides methods to query and manipulate report records in database
 *
 * What is JpaRepository?
 * - Spring Data JPA interface that provides ready-made database operations
 * - You don't write SQL or implementation code
 * - Spring generates the implementation automatically at runtime
 *
 * Built-in methods we get for free:
 * - save(report): Insert or update a report
 * - findById(id): Find report by ID
 * - findAll(): Get all reports
 * - deleteById(id): Delete report by ID
 * - count(): Count total reports
 * - existsById(id): Check if report exists
 *
 * Custom Query Methods:
 * Spring Data JPA can generate SQL from method names!
 *
 * Method naming convention:
 * - findBy{FieldName}: Find records by a field
 * - findBy{Field1}And{Field2}: Combine multiple conditions with AND
 * - findBy{Field1}Or{Field2}: Combine multiple conditions with OR
 * - findBy{Field}OrderBy{Field}Desc: Sort results
 * - findBy{Field}Between: Range queries
 *
 * Example: findByRequestedBy("admin@example.com")
 * Generated SQL: SELECT * FROM reports WHERE requested_by = 'admin@example.com'
 *
 * @Repository - Marks this as a data access component (optional with JpaRepository)
 */
@Repository
public interface ReportRepository extends JpaRepository<Report, Long> {

    /**
     * FIND REPORTS BY USER
     *
     * Get all reports generated by a specific user
     * Sorted by most recent first
     *
     * Method name breakdown:
     * - findBy: Start of query method
     * - RequestedBy: Field name to filter (requestedBy in Report entity)
     * - OrderBy: Start sorting clause
     * - GeneratedAt: Field to sort by
     * - Desc: Descending order (newest first)
     *
     * Generated SQL:
     * SELECT * FROM reports
     * WHERE requested_by = ?
     * ORDER BY generated_at DESC
     *
     * Use case:
     * "Show me all reports generated by john@example.com"
     * List<Report> reports = reportRepository.findByRequestedByOrderByGeneratedAtDesc("john@example.com");
     *
     * @param requestedBy Username or email of user who requested reports
     * @return List of reports sorted by newest first
     */
    List<Report> findByRequestedByOrderByGeneratedAtDesc(String requestedBy);

    /**
     * FIND REPORTS BY TYPE
     *
     * Get all reports of a specific type
     * With pagination support
     *
     * Generated SQL:
     * SELECT * FROM reports
     * WHERE report_type = ?
     * ORDER BY [pagination settings]
     * LIMIT ? OFFSET ?
     *
     * Use case:
     * "Show me all member statements, 10 per page"
     * Pageable pageable = PageRequest.of(0, 10);
     * Page<Report> reports = reportRepository.findByReportType(ReportType.MEMBER_STATEMENT, pageable);
     *
     * Pagination benefits:
     * - Don't load thousands of reports at once
     * - Better performance
     * - User-friendly navigation
     *
     * @param reportType Type of report (MEMBER_STATEMENT, EMPLOYER_REPORT, etc.)
     * @param pageable Pagination settings (page number, size, sort)
     * @return Page containing matching reports
     */
    Page<Report> findByReportType(ReportType reportType, Pageable pageable);

    /**
     * FIND REPORTS BY FORMAT
     *
     * Get all reports in a specific format
     * Useful for analytics or bulk operations
     *
     * Generated SQL:
     * SELECT * FROM reports
     * WHERE format = ?
     * ORDER BY generated_at DESC
     *
     * Use case:
     * "Find all PDF reports for archival"
     * List<Report> pdfs = reportRepository.findByFormatOrderByGeneratedAtDesc(ReportFormat.PDF);
     *
     * @param format File format (PDF, EXCEL, CSV)
     * @return List of reports in that format
     */
    List<Report> findByFormatOrderByGeneratedAtDesc(ReportFormat format);

    /**
     * FIND REPORTS BY TYPE AND ENTITY ID
     *
     * Get reports for a specific entity (member, employer, etc.)
     * Filtered by report type
     *
     * Method name breakdown:
     * - findBy: Start query
     * - ReportType: First filter field
     * - And: Combine conditions with AND
     * - EntityId: Second filter field
     * - OrderBy: Start sorting
     * - GeneratedAt: Sort field
     * - Desc: Descending (newest first)
     *
     * Generated SQL:
     * SELECT * FROM reports
     * WHERE report_type = ? AND entity_id = ?
     * ORDER BY generated_at DESC
     *
     * Use case:
     * "Show me all member statements for member #123"
     * List<Report> statements = reportRepository.findByReportTypeAndEntityIdOrderByGeneratedAtDesc(
     *     ReportType.MEMBER_STATEMENT, 123L
     * );
     *
     * Why useful?
     * - Member viewing their own report history
     * - Admin checking what reports were generated for an entity
     * - Avoiding duplicate report generation
     *
     * @param reportType Type of report
     * @param entityId ID of the entity (member ID, employer ID, etc.)
     * @return List of matching reports
     */
    List<Report> findByReportTypeAndEntityIdOrderByGeneratedAtDesc(ReportType reportType, Long entityId);

    /**
     * FIND REPORTS GENERATED WITHIN DATE RANGE
     *
     * Get reports generated between two dates
     * Useful for monthly/quarterly reporting and cleanup
     *
     * Method name breakdown:
     * - findBy: Start query
     * - GeneratedAt: Field to filter
     * - Between: Range operator (inclusive on both ends)
     *
     * Generated SQL:
     * SELECT * FROM reports
     * WHERE generated_at BETWEEN ? AND ?
     *
     * Use case:
     * "Find all reports generated in January 2025"
     * LocalDateTime start = LocalDateTime.of(2025, 1, 1, 0, 0);
     * LocalDateTime end = LocalDateTime.of(2025, 1, 31, 23, 59, 59);
     * List<Report> januaryReports = reportRepository.findByGeneratedAtBetween(start, end);
     *
     * Common uses:
     * - Monthly report summaries
     * - Storage cleanup (delete reports older than X days)
     * - Usage analytics
     * - Compliance audits
     *
     * @param start Start of date range (inclusive)
     * @param end End of date range (inclusive)
     * @return List of reports generated in that period
     */
    List<Report> findByGeneratedAtBetween(LocalDateTime start, LocalDateTime end);

    /**
     * FIND REPORTS BY STATUS
     *
     * Get reports in a specific status
     * Important for monitoring background jobs
     *
     * Generated SQL:
     * SELECT * FROM reports
     * WHERE status = ?
     * ORDER BY generated_at DESC
     *
     * Use case 1: Find failed reports
     * List<Report> failedReports = reportRepository.findByStatusOrderByGeneratedAtDesc("FAILED");
     * // Alert admin or retry generation
     *
     * Use case 2: Find pending reports
     * List<Report> pendingReports = reportRepository.findByStatusOrderByGeneratedAtDesc("PENDING");
     * // Process next report in queue
     *
     * @param status Report status (PENDING, PROCESSING, COMPLETED, FAILED)
     * @return List of reports with that status
     */
    List<Report> findByStatusOrderByGeneratedAtDesc(String status);

    /**
     * COUNT REPORTS BY USER
     *
     * Count how many reports a user has generated
     * Useful for quotas or analytics
     *
     * Method name breakdown:
     * - countBy: Count instead of find
     * - RequestedBy: Field to filter by
     *
     * Generated SQL:
     * SELECT COUNT(*) FROM reports
     * WHERE requested_by = ?
     *
     * Use case:
     * "Check if user has exceeded monthly report limit"
     * long userReportCount = reportRepository.countByRequestedBy("admin@example.com");
     * if (userReportCount > 100) {
     *     throw new Exception("Monthly limit exceeded");
     * }
     *
     * @param requestedBy Username/email to count reports for
     * @return Number of reports generated by that user
     */
    long countByRequestedBy(String requestedBy);

    /**
     * FIND REPORTS WITH CUSTOM QUERY (ADVANCED)
     *
     * Custom JPQL query to find reports by user with specific type and format
     * Demonstrates @Query annotation for complex queries
     *
     * @Query annotation:
     * - Allows writing custom JPQL (Java Persistence Query Language)
     * - Use when method name would be too long/complex
     * - More flexible than method naming convention
     *
     * JPQL vs SQL:
     * - JPQL uses entity names and field names (Report, requestedBy)
     * - SQL uses table names and column names (reports, requested_by)
     * - JPQL is database-independent
     *
     * Query breakdown:
     * - SELECT r: Select Report entity (alias 'r')
     * - FROM Report r: From Report entity table
     * - WHERE r.requestedBy = :requestedBy: Filter by user (named parameter)
     * - AND r.reportType = :reportType: Filter by type
     * - AND r.format = :format: Filter by format
     * - ORDER BY r.generatedAt DESC: Sort newest first
     *
     * Named parameters:
     * - :requestedBy, :reportType, :format
     * - Mapped to method parameters using @Param annotation
     * - Safer than string concatenation (prevents SQL injection)
     *
     * Use case:
     * "Show me all PDF member statements generated by admin"
     * List<Report> reports = reportRepository.findByUserAndTypeAndFormat(
     *     "admin@example.com",
     *     ReportType.MEMBER_STATEMENT,
     *     ReportFormat.PDF
     * );
     *
     * @param requestedBy User who generated reports
     * @param reportType Type of report
     * @param format File format
     * @return List of matching reports
     */
    @Query("SELECT r FROM Report r WHERE r.requestedBy = :requestedBy " +
           "AND r.reportType = :reportType AND r.format = :format " +
           "ORDER BY r.generatedAt DESC")
    List<Report> findByUserAndTypeAndFormat(
            @Param("requestedBy") String requestedBy,
            @Param("reportType") ReportType reportType,
            @Param("format") ReportFormat format
    );

    /**
     * GET TOTAL FILE SIZE BY USER
     *
     * Calculate total storage used by a user's reports
     * Useful for storage quotas and billing
     *
     * @Query with aggregate function:
     * - SUM(r.fileSize): Add up all file sizes
     * - Returns Long (total bytes)
     * - Returns 0 if user has no reports (COALESCE)
     *
     * Query breakdown:
     * SELECT COALESCE(SUM(r.fileSize), 0)
     * - SUM(r.fileSize): Add all file sizes
     * - COALESCE(..., 0): If NULL (no reports), return 0 instead
     *
     * Use case:
     * "Check if user is within 1GB storage quota"
     * Long totalBytes = reportRepository.getTotalFileSizeByUser("admin@example.com");
     * Long oneGigabyte = 1073741824L; // 1GB in bytes
     * if (totalBytes > oneGigabyte) {
     *     notifyUserAboutQuota();
     * }
     *
     * Display to user:
     * "You have used 750 MB of your 1 GB quota"
     *
     * @param requestedBy User to calculate storage for
     * @return Total file size in bytes
     */
    @Query("SELECT COALESCE(SUM(r.fileSize), 0) FROM Report r WHERE r.requestedBy = :requestedBy")
    Long getTotalFileSizeByUser(@Param("requestedBy") String requestedBy);

    /**
     * DELETE OLD REPORTS
     *
     * Remove reports older than a specific date
     * Used for automatic cleanup jobs
     *
     * @Query with DELETE:
     * - DELETE FROM Report r: Remove records
     * - WHERE r.generatedAt < :cutoffDate: Older than cutoff
     *
     * Use case:
     * "Delete reports older than 90 days"
     * LocalDateTime cutoffDate = LocalDateTime.now().minusDays(90);
     * int deletedCount = reportRepository.deleteOldReports(cutoffDate);
     * log.info("Deleted {} old reports", deletedCount);
     *
     * Best practices:
     * - Run as scheduled job (e.g., daily at midnight)
     * - Archive important reports before deletion
     * - Notify users before deleting their reports
     * - Check compliance requirements (some reports must be kept)
     *
     * @param cutoffDate Delete reports generated before this date
     * @return Number of reports deleted
     */
    @Query("DELETE FROM Report r WHERE r.generatedAt < :cutoffDate")
    int deleteOldReports(@Param("cutoffDate") LocalDateTime cutoffDate);

    /**
     * FIND LATEST REPORT FOR ENTITY
     *
     * Get the most recent report for a specific entity and type
     * Useful to avoid regenerating recent reports
     *
     * Query breakdown:
     * - TOP 1 equivalent in JPQL: We limit results to 1 with Pageable
     * - ORDER BY r.generatedAt DESC: Most recent first
     * - Then take first result
     *
     * Use case:
     * "Check if member statement was generated today"
     * List<Report> recent = reportRepository.findLatestReportForEntity(
     *     ReportType.MEMBER_STATEMENT,
     *     123L,
     *     PageRequest.of(0, 1)
     * );
     *
     * if (!recent.isEmpty()) {
     *     Report latest = recent.get(0);
     *     if (latest.getGeneratedAt().isAfter(LocalDateTime.now().minusHours(24))) {
     *         // Reuse existing report instead of regenerating
     *         return latest;
     *     }
     * }
     *
     * @param reportType Type of report
     * @param entityId Entity ID
     * @param pageable Should be PageRequest.of(0, 1) to get only the latest
     * @return List containing at most one report (the latest)
     */
    @Query("SELECT r FROM Report r WHERE r.reportType = :reportType " +
           "AND r.entityId = :entityId AND r.status = 'COMPLETED' " +
           "ORDER BY r.generatedAt DESC")
    List<Report> findLatestReportForEntity(
            @Param("reportType") ReportType reportType,
            @Param("entityId") Long entityId,
            Pageable pageable
    );
}

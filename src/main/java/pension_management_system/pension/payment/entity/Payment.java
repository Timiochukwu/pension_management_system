package pension_management_system.pension.payment.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import pension_management_system.pension.contribution.entity.Contribution;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Payment Entity - Represents a payment transaction
 *
 * Purpose: Track all payment attempts and their outcomes
 *
 * What is a Payment record?
 * - Database record of each payment attempt
 * - Links contribution to payment gateway transaction
 * - Stores payment gateway details and responses
 * - Enables reconciliation and audit trail
 *
 * Why separate from Contribution?
 * - One contribution may have multiple payment attempts (retries)
 * - Contribution = what member owes
 * - Payment = how they tried to pay
 * - Clean separation of concerns
 *
 * Example scenario:
 * 1. Member creates contribution: ₦10,000
 * 2. First payment attempt → FAILED (card declined)
 * 3. Second payment attempt → FAILED (insufficient funds)
 * 4. Third payment attempt → SUCCESS
 *
 * Result: 1 Contribution, 3 Payment records
 *
 * Database Table: payments
 *
 * Annotations Explained:
 * @Entity - JPA entity (maps to database table)
 * @Table - Specify table name
 * @Data - Lombok: getters, setters, toString, equals, hashCode
 * @Builder - Lombok: builder pattern
 * @NoArgsConstructor - Lombok: no-arg constructor (required by JPA)
 * @AllArgsConstructor - Lombok: all-args constructor (used by @Builder)
 */
@Entity
@Table(name = "payments")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Payment {

    /**
     * UNIQUE IDENTIFIER
     *
     * Primary key for payment record
     * Auto-generated by database
     *
     * Example: 1, 2, 3, ...
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * PAYMENT REFERENCE (UNIQUE)
     *
     * Our internal unique reference for this payment
     * Used to track payment across system
     * Different from gateway reference
     *
     * Format: PMT-{timestamp}-{random}
     * Example: "PMT-20250115-ABC123"
     *
     * Why needed?
     * - Unique identifier we control
     * - Used in URLs, APIs, logs
     * - Gateway-independent tracking
     * - Easy to communicate to users
     *
     * Use case:
     * - User: "My payment reference is PMT-20250115-ABC123"
     * - Support: Looks up payment in system
     * - Finds all details including gateway info
     *
     * @Column unique=true ensures no duplicates
     */
    @Column(nullable = false, unique = true, length = 100)
    private String reference;

    /**
     * CONTRIBUTION (LINK TO WHAT'S BEING PAID)
     *
     * Link to the contribution being paid for
     * Many payments can attempt to pay one contribution
     *
     * Relationship: Many-to-One
     * - Many payments → One contribution
     * - Multiple payment attempts allowed
     *
     * @ManyToOne - Many payments can link to one contribution
     * @JoinColumn - Foreign key column in payments table
     *
     * Database: contribution_id column stores contribution's ID
     *
     * Example:
     * Contribution contribution = contributionRepository.findById(123L);
     * Payment payment = Payment.builder()
     *     .contribution(contribution)
     *     .build();
     *
     * Query usage:
     * // Find all payment attempts for a contribution
     * List<Payment> attempts = paymentRepository.findByContribution(contribution);
     */
    @ManyToOne
    @JoinColumn(name = "contribution_id", nullable = false)
    private Contribution contribution;

    /**
     * PAYMENT AMOUNT
     *
     * Amount being paid (in currency)
     * Should match contribution amount
     *
     * Precision: 19 digits total, 2 after decimal
     * Example: 10000.00 (₦10,000)
     *
     * Why store separately?
     * - Contribution amount might change
     * - Payment freezes amount at payment time
     * - Enables partial payments (future feature)
     *
     * Validation:
     * - Must be > 0
     * - Usually equals contribution amount
     * - May differ if fees/discounts applied
     */
    @Column(nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;

    /**
     * PAYMENT GATEWAY
     *
     * Which payment processor is being used
     *
     * Values: PAYSTACK, FLUTTERWAVE, MANUAL
     *
     * @Enumerated(EnumType.STRING) - Store as text in database
     * - Stored as: "PAYSTACK", "FLUTTERWAVE", etc.
     * - More readable than numbers
     * - Easier to debug
     *
     * Why track this?
     * - Different gateways need different verification logic
     * - Reconciliation by gateway
     * - Performance comparison between gateways
     * - Routing logic for future payments
     *
     * Example:
     * if (payment.getGateway() == PaymentGateway.PAYSTACK) {
     *     paystackService.verifyPayment(payment.getGatewayReference());
     * } else if (payment.getGateway() == PaymentGateway.FLUTTERWAVE) {
     *     flutterwaveService.verifyPayment(payment.getGatewayReference());
     * }
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private PaymentGateway gateway;

    /**
     * GATEWAY REFERENCE
     *
     * Payment gateway's unique reference for this transaction
     * Different from our reference
     *
     * Examples:
     * - Paystack: "ref_1234567890"
     * - Flutterwave: "flw_tx_1234567890"
     *
     * Why important?
     * - Required to verify payment with gateway
     * - Used in gateway API calls
     * - Needed for refunds
     * - Reconciliation with gateway
     *
     * Nullable: Only set after gateway initialization
     * Initially null when status = INITIATED
     *
     * Example usage:
     * // Verify with Paystack
     * String url = "https://api.paystack.co/transaction/verify/" +
     *              payment.getGatewayReference();
     */
    @Column(length = 255)
    private String gatewayReference;

    /**
     * PAYMENT STATUS
     *
     * Current status of the payment
     *
     * Lifecycle:
     * INITIATED → PENDING → PROCESSING → SUCCESS
     *                    ↘ FAILED
     *                    ↘ CANCELLED
     *                    ↘ EXPIRED
     *
     * See PaymentStatus enum for details on each status
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private PaymentStatus status;

    /**
     * AUTHORIZATION URL
     *
     * URL where user should go to complete payment
     * Provided by payment gateway
     *
     * Examples:
     * - Paystack: "https://checkout.paystack.com/abc123"
     * - Flutterwave: "https://checkout.flutterwave.com/v3/hosted/pay/xyz789"
     *
     * How it's used:
     * 1. Initialize payment with gateway
     * 2. Gateway returns authorization URL
     * 3. We store it here
     * 4. Redirect user to this URL
     * 5. User completes payment on gateway's page
     * 6. Gateway redirects back to our callback URL
     *
     * Example:
     * // In controller
     * return "redirect:" + payment.getAuthorizationUrl();
     *
     * Nullable: Only for gateway payments (not MANUAL)
     */
    @Column(length = 500)
    private String authorizationUrl;

    /**
     * CALLBACK URL
     *
     * Where payment gateway should redirect after payment
     * URL on our server
     *
     * Examples:
     * - "https://pension.com/api/v1/payments/callback?reference=PMT-123"
     * - "https://pension.com/payment/success?ref=PMT-123"
     *
     * How it works:
     * 1. User completes payment on gateway
     * 2. Gateway redirects to this URL
     * 3. Our controller handles the callback
     * 4. We verify payment
     * 5. Show success/failure page to user
     *
     * Example URL with parameters:
     * https://pension.com/api/v1/payments/callback
     *   ?reference=PMT-123
     *   &trxref=ref_1234567890
     *   &status=success
     */
    @Column(length = 500)
    private String callbackUrl;

    /**
     * GATEWAY RESPONSE (JSON)
     *
     * Raw response from payment gateway
     * Stored as JSON text for audit and debugging
     *
     * Contains:
     * - Verification response
     * - Transaction details
     * - Gateway metadata
     *
     * Example (Paystack):
     * {
     *   "status": true,
     *   "message": "Verification successful",
     *   "data": {
     *     "id": 1234567890,
     *     "status": "success",
     *     "reference": "ref_1234567890",
     *     "amount": 1000000,
     *     "paid_at": "2025-01-15T10:30:45.000Z",
     *     "channel": "card",
     *     "currency": "NGN"
     *   }
     * }
     *
     * Why store this?
     * - Audit trail
     * - Debugging failures
     * - Reconciliation
     * - Compliance/legal evidence
     *
     * @Column(columnDefinition = "TEXT") - Allows large JSON
     */
    @Column(columnDefinition = "TEXT")
    private String gatewayResponse;

    /**
     * FAILURE REASON
     *
     * Why payment failed (if status = FAILED)
     * User-friendly error message
     *
     * Examples:
     * - "Insufficient funds"
     * - "Card declined by bank"
     * - "Invalid card number"
     * - "Payment timeout"
     * - "Network error"
     *
     * How to get:
     * - Extract from gateway response
     * - Translate technical errors to user-friendly
     * - Store for user display and support
     *
     * Example:
     * if (payment.getStatus() == PaymentStatus.FAILED) {
     *     showError(payment.getFailureReason());
     * }
     */
    @Column(length = 500)
    private String failureReason;

    /**
     * PAYMENT CHANNEL
     *
     * How user paid (card, bank, etc.)
     * Provided by gateway after payment
     *
     * Examples:
     * - "card" (credit/debit card)
     * - "bank" (bank transfer)
     * - "ussd" (USSD code)
     * - "bank_transfer" (direct bank transfer)
     * - "mobile_money" (mobile wallet)
     *
     * Why track?
     * - Analytics: Which channels are popular?
     * - Cost analysis: Card fees vs bank transfer
     * - User experience: Optimize popular channels
     *
     * Example report:
     * - 60% use cards
     * - 30% use bank transfer
     * - 10% use mobile money
     */
    @Column(length = 50)
    private String paymentChannel;

    /**
     * CREATED AT
     *
     * When payment record was created
     * Automatically set on creation
     *
     * @CreationTimestamp - Hibernate sets this automatically
     */
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * PAID AT
     *
     * When payment was successfully completed
     * Only set when status = SUCCESS
     *
     * Use cases:
     * - Show user when they paid
     * - Calculate processing time
     * - Reconciliation reports
     *
     * Example:
     * if (payment.getStatus() == PaymentStatus.SUCCESS) {
     *     System.out.println("Paid at: " + payment.getPaidAt());
     * }
     */
    private LocalDateTime paidAt;

    /**
     * UPDATED AT
     *
     * Last time payment record was modified
     * Automatically updated on save
     *
     * @UpdateTimestamp - Hibernate updates this automatically
     */
    private LocalDateTime updatedAt;

    /**
     * IP ADDRESS
     *
     * IP address of user making payment
     * For security and fraud detection
     *
     * Examples:
     * - "192.168.1.100"
     * - "41.203.x.x"
     *
     * Why track?
     * - Fraud detection: Multiple failed payments from same IP
     * - Location verification: Payment from unusual location
     * - Compliance: Required by some regulations
     *
     * Privacy: Store responsibly, comply with GDPR/local laws
     */
    @Column(length = 45)
    private String ipAddress;

    /**
     * USER AGENT
     *
     * Browser/device information
     * For analytics and fraud detection
     *
     * Example:
     * "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36..."
     *
     * Why track?
     * - Detect automated bots
     * - Device analytics: Mobile vs desktop
     * - Browser compatibility issues
     */
    @Column(length = 500)
    private String userAgent;

    /**
     * METADATA (JSON)
     *
     * Additional flexible data
     * Stored as JSON for extensibility
     *
     * Examples:
     * {
     *   "employerId": 123,
     *   "payrollMonth": "2025-01",
     *   "bonusContribution": true
     * }
     *
     * Use cases:
     * - Store extra context
     * - Integration data
     * - Custom fields per client
     */
    @Column(columnDefinition = "TEXT")
    private String metadata;

    /**
     * LIFECYCLE HOOK: Before persisting
     *
     * Automatically called by JPA before saving new record
     * Sets createdAt and updatedAt
     */
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    /**
     * LIFECYCLE HOOK: Before updating
     *
     * Automatically called by JPA before updating existing record
     * Updates updatedAt
     */
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * HELPER METHOD: Mark payment as successful
     *
     * Updates status and sets paid timestamp
     *
     * @param gatewayResponse Raw response from gateway
     */
    public void markAsSuccessful(String gatewayResponse) {
        this.status = PaymentStatus.SUCCESS;
        this.paidAt = LocalDateTime.now();
        this.gatewayResponse = gatewayResponse;
    }

    /**
     * HELPER METHOD: Mark payment as failed
     *
     * Updates status and stores failure reason
     *
     * @param reason Why payment failed
     * @param gatewayResponse Raw response from gateway
     */
    public void markAsFailed(String reason, String gatewayResponse) {
        this.status = PaymentStatus.FAILED;
        this.failureReason = reason;
        this.gatewayResponse = gatewayResponse;
    }

    /**
     * HELPER METHOD: Check if payment is successful
     *
     * @return true if payment completed successfully
     */
    public boolean isSuccessful() {
        return this.status == PaymentStatus.SUCCESS;
    }

    /**
     * HELPER METHOD: Check if payment can be retried
     *
     * @return true if payment failed/cancelled and can be tried again
     */
    public boolean canRetry() {
        return this.status == PaymentStatus.FAILED ||
               this.status == PaymentStatus.CANCELLED ||
               this.status == PaymentStatus.EXPIRED;
    }
}
